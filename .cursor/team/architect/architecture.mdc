---
description: Architecture de l'application Pluvio
alwaysApply: true
---

# Architecture de l'Application Pluvio

## Vue d'ensemble

Application de logging quotidien de la pluviométrie avec architecture modulaire et évolutive.

## Principes Architecturaux

### Clean Architecture

- **Séparation des responsabilités** : Chaque couche a une responsabilité unique et claire
- **Indépendance des frameworks** : Le code métier ne dépend pas des frameworks
- **Testabilité** : Chaque composant peut être testé indépendamment
- **Indépendance de l'UI** : L'interface peut changer sans affecter le code métier
- **Indépendance de la base de données** : Le stockage peut être changé sans affecter le reste

### Clean Code

- **Noms explicites** : Variables, fonctions et classes avec des noms qui expriment leur intention
- **Fonctions courtes** : Une fonction = une responsabilité
- **Pas de duplication** : DRY (Don't Repeat Yourself)
- **Commentaires utiles** : Expliquer le "pourquoi", pas le "comment"
- **Formatage cohérent** : Code uniforme dans tout le projet

## Structure des Couches

```
┌─────────────────────────────────────┐
│         Presentation Layer          │
│    (UI Components, Forms, Views)    │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│        Application Layer             │
│   (Use Cases, Business Logic)        │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│          Domain Layer                │
│   (Entities, Value Objects, Rules)  │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│      Infrastructure Layer            │
│  (Storage, APIs, External Services)  │
└─────────────────────────────────────┘
```

## Couches Détaillées

### 1. Domain Layer (Cœur Métier)

**Responsabilités :**
- Définir les entités métier (RainfallEntry, etc.)
- Définir les règles de validation métier
- Définir les interfaces des repositories (abstractions)

**Exemples :**
- `RainfallEntry` : Entité représentant un enregistrement de pluie
- `IRainfallRepository` : Interface pour le stockage
- `RainfallValidator` : Validation des règles métier

**Règles :**
- Aucune dépendance vers les autres couches
- Pas de frameworks externes
- Code pur, testable unitairement

### 2. Application Layer (Cas d'Usage)

**Responsabilités :**
- Orchestrer les opérations métier
- Coordonner entre domain et infrastructure
- Gérer les transactions et la logique applicative

**Exemples :**
- `LogRainfallUseCase` : Cas d'usage pour enregistrer une pluviométrie
- `GetRainfallStatsUseCase` : Cas d'usage pour obtenir des statistiques
- `ExportRainfallDataUseCase` : Cas d'usage pour exporter les données
- `ExportRainfallToCsvUseCase` : Cas d'usage pour exporter les données au format CSV

**Règles :**
- Dépend uniquement de la couche Domain
- Contient la logique applicative (pas métier)
- Peut utiliser des services de l'infrastructure via des interfaces

### 3. Infrastructure Layer (Implémentations)

**Responsabilités :**
- Implémenter les repositories (base de données, fichiers, APIs)
- Gérer les communications externes
- Implémenter les services techniques

**Exemples :**
- `LocalStorageRainfallRepository` : Stockage local
- `FileSystemRainfallRepository` : Stockage fichier
- `APIRainfallRepository` : Stockage via API

**Règles :**
- Implémente les interfaces définies dans Domain
- Peut utiliser des frameworks et bibliothèques externes
- Isolé du reste de l'application

### 4. Presentation Layer (Interface Utilisateur)

**Responsabilités :**
- Afficher les données à l'utilisateur
- Capturer les interactions utilisateur
- Formater les données pour l'affichage

**Exemples :**
- `RainfallForm` : Formulaire d'enregistrement
- `RainfallList` : Liste des enregistrements
- `RainfallChart` : Graphiques de visualisation

**Règles :**
- Dépend de l'Application Layer (use cases)
- Ne contient pas de logique métier
- Peut utiliser des frameworks UI (React, Vue, etc.)

## Flux de Données

### Enregistrement d'une pluviométrie

```
User Input (Form)
    ↓
Presentation Layer (RainfallForm)
    ↓
Application Layer (LogRainfallUseCase)
    ↓
Domain Layer (RainfallEntry + Validation)
    ↓
Infrastructure Layer (RainfallRepository.save)
    ↓
Storage (LocalStorage/File/API)
```

### Récupération des données

```
User Request (View)
    ↓
Presentation Layer (RainfallList)
    ↓
Application Layer (GetRainfallByDateRangeUseCase)
    ↓
Infrastructure Layer (RainfallRepository.findByDateRange)
    ↓
Storage (LocalStorage/File/API)
    ↓
Domain Layer (RainfallEntry[])
    ↓
Application Layer (Format for display)
    ↓
Presentation Layer (Display)
```

## Choix Technologiques

### Décisions Architecturales (2026-01-17)

Pour la première fonctionnalité (saisie et visualisation de pluviométrie), les choix suivants ont été validés :

#### Stack Technique

- **Langage** : TypeScript
  - Typage statique pour la sécurité et la maintenabilité
  - Supporté par tous les frameworks modernes
  - Facilite la détection d'erreurs à la compilation

- **Frontend** : React 18+ avec TypeScript
  - Framework mature et largement adopté
  - Excellent écosystème de tests
  - Composants réutilisables et modulaires
  - Bonne performance pour des applications de taille moyenne

- **Backend/Runtime** : Node.js avec TypeScript
  - Cohérent avec le frontend (même langage)
  - Accès natif à SQLite via `better-sqlite3` ou `sql.js`
  - Peut évoluer vers une API REST si nécessaire

- **Stockage** : SQLite
  - Base de données légère et embarquée
  - Pas besoin de serveur de base de données séparé
  - Fichier local `pluvio.db`
  - Support des transactions
  - Bibliothèque : `better-sqlite3` (synchrone, performante) ou `sql.js` (pour le web)

- **Graphiques** : Recharts
  - Bibliothèque React native
  - Simple à utiliser et bien documentée
  - Support TypeScript
  - Alternatives considérées : Chart.js (plus lourd), Victory (plus complexe)

- **Tests** :
  - **Unitaires/Intégration** : Jest + React Testing Library
  - **E2E** : Playwright
  - **Couverture** : Jest coverage

- **Build Tool** : Vite
  - Rapide et moderne
  - Excellent support TypeScript
  - Hot Module Replacement (HMR) pour le développement
  - Build optimisé pour la production

- **Gestionnaire de paquets** : npm ou pnpm
  - npm : standard, bien supporté
  - pnpm : plus rapide, économise l'espace disque

#### Structure du Projet

```
pluvio/
├── src/
│   ├── domain/              # Domain Layer
│   │   ├── entities/
│   │   │   └── RainfallEntry.ts
│   │   ├── repositories/
│   │   │   └── IRainfallRepository.ts
│   │   └── validators/
│   │       └── RainfallValidator.ts
│   ├── application/         # Application Layer
│   │   └── use-cases/
│   │       ├── LogRainfallUseCase.ts
│   │       └── GetRainfallEntriesUseCase.ts
│   ├── infrastructure/      # Infrastructure Layer
│   │   └── repositories/
│   │       └── SQLiteRainfallRepository.ts
│   └── presentation/        # Presentation Layer
│       ├── components/
│       │   ├── RainfallForm.tsx
│       │   ├── RainfallTable.tsx
│       │   └── RainfallChart.tsx
│       └── App.tsx
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── pluvio.db                # Base SQLite (générée)
└── package.json
```

### Critères de Sélection Appliqués

1. **Simplicité** : ✅ Stack moderne mais simple, TypeScript pour la clarté
2. **Performance** : ✅ Vite pour le build rapide, SQLite pour le stockage efficace
3. **Écosystème** : ✅ React et Node.js ont d'excellents écosystèmes
4. **Testabilité** : ✅ Jest et React Testing Library sont des standards
5. **Évolutivité** : ✅ Architecture modulaire permet d'ajouter facilement des fonctionnalités

## Dépendances

### Dépendances Externes (Définies)

#### Production

- **react** : ^18.2.0 - Framework UI
- **react-dom** : ^18.2.0 - Rendu React
- **better-sqlite3** : ^9.x - Client SQLite (ou sql.js pour web)
- **recharts** : ^2.x - Bibliothèque de graphiques
- **date-fns** : ^2.x - Manipulation de dates (légère et moderne)

#### Développement

- **typescript** : ^5.x - Langage
- **@types/react** : ^18.x - Types React
- **@types/node** : ^20.x - Types Node.js
- **vite** : ^5.x - Build tool
- **@vitejs/plugin-react** : ^4.x - Plugin React pour Vite

#### Tests

- **jest** : ^29.x - Framework de tests
- **@testing-library/react** : ^14.x - Tests React
- **@testing-library/jest-dom** : ^6.x - Matchers DOM
- **playwright** : ^1.x - Tests E2E
- **@types/jest** : ^29.x - Types Jest

### Gestion des Dépendances

- Utiliser npm ou pnpm comme gestionnaire de paquets
- Documenter toutes les dépendances dans `package.json`
- Utiliser des versions exactes pour les dépendances critiques (^ pour les mineures)
- Maintenir les dépendances à jour régulièrement
- Éviter les dépendances inutiles
- Auditer régulièrement avec `npm audit`

## Évolutivité

### Extensions Futures Possibles

- Support multi-utilisateurs
- Synchronisation cloud
- Notifications et rappels
- Export vers différents formats
- Intégration avec APIs météo
- Analyse prédictive
- Application mobile

### Architecture Évolutive

- Interfaces clairement définies pour faciliter les extensions
- Injection de dépendances pour la flexibilité
- Configuration externalisée
- Plugins/modules pour nouvelles fonctionnalités

## Sécurité

### Considérations

- Validation de toutes les entrées utilisateur
- Sanitisation des données
- Protection contre les injections
- Gestion sécurisée des données sensibles
- Authentification/authorization (si multi-utilisateurs)

## Performance

### Optimisations

- Lazy loading des données
- Pagination pour grandes listes
- Mise en cache des calculs
- Optimisation des requêtes
- Compression des données si nécessaire

## Documentation

- Chaque couche doit être documentée
- Les interfaces doivent avoir des JSDoc/commentaires
- Les cas d'usage doivent être documentés
- Les décisions architecturales doivent être tracées dans le team-log.md
